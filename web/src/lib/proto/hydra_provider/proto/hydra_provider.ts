// @generated by protobuf-ts 2.9.3
// @generated from protobuf file "hydra_provider/proto/hydra_provider.proto" (package "hydra_provider", syntax proto3)
// tslint:disable
import { ServiceType } from '@protobuf-ts/runtime-rpc';
import { WireType } from '@protobuf-ts/runtime';
import type { BinaryWriteOptions } from '@protobuf-ts/runtime';
import type { IBinaryWriter } from '@protobuf-ts/runtime';
import { UnknownFieldHandler } from '@protobuf-ts/runtime';
import type { BinaryReadOptions } from '@protobuf-ts/runtime';
import type { IBinaryReader } from '@protobuf-ts/runtime';
import type { PartialMessage } from '@protobuf-ts/runtime';
import { reflectionMergePartial } from '@protobuf-ts/runtime';
import { MessageType } from '@protobuf-ts/runtime';
/**
 * @generated from protobuf message hydra_provider.Empty
 */
export interface Empty {}
/**
 * @generated from protobuf message hydra_provider.HelloRequest
 */
export interface HelloRequest {
	/**
	 * @generated from protobuf field: string name = 1;
	 */
	name: string;
}
/**
 * @generated from protobuf message hydra_provider.HelloReply
 */
export interface HelloReply {
	/**
	 * @generated from protobuf field: string message = 1;
	 */
	message: string;
}
/**
 * @generated from protobuf message hydra_provider.ConnectionTypeMessage
 */
export interface ConnectionTypeMessage {
	/**
	 * @generated from protobuf field: hydra_provider.ConnectionType connectionType = 1;
	 */
	connectionType: ConnectionType;
}
/**
 * @generated from protobuf message hydra_provider.GetSerialPortsReply
 */
export interface GetSerialPortsReply {
	/**
	 * @generated from protobuf field: repeated string ports = 1;
	 */
	ports: string[];
}
/**
 * @generated from protobuf message hydra_provider.SetSerialConnectionRequest
 */
export interface SetSerialConnectionRequest {
	/**
	 * @generated from protobuf field: string portName = 1;
	 */
	portName: string;
}
/**
 * @generated from protobuf message hydra_provider.CheckConnectionReply
 */
export interface CheckConnectionReply {
	/**
	 * @generated from protobuf field: bool connected = 1;
	 */
	connected: boolean;
	/**
	 * @generated from protobuf field: hydra_provider.ConnectionType connectionType = 2;
	 */
	connectionType: ConnectionType;
	/**
	 * @generated from protobuf field: repeated string errors = 3;
	 */
	errors: string[];
}
/**
 * @generated from protobuf enum hydra_provider.ConnectionType
 */
export enum ConnectionType {
	/**
	 * @generated from protobuf enum value: SERIAL = 0;
	 */
	SERIAL = 0,
	/**
	 * @generated from protobuf enum value: RANDOM = 1;
	 */
	RANDOM = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class Empty$Type extends MessageType<Empty> {
	constructor() {
		super('hydra_provider.Empty', []);
	}
	create(value?: PartialMessage<Empty>): Empty {
		const message = globalThis.Object.create(this.messagePrototype!);
		if (value !== undefined) reflectionMergePartial<Empty>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: Empty
	): Empty {
		return target ?? this.create();
	}
	internalBinaryWrite(
		message: Empty,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message hydra_provider.Empty
 */
export const Empty = new Empty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HelloRequest$Type extends MessageType<HelloRequest> {
	constructor() {
		super('hydra_provider.HelloRequest', [
			{ no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
		]);
	}
	create(value?: PartialMessage<HelloRequest>): HelloRequest {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.name = '';
		if (value !== undefined) reflectionMergePartial<HelloRequest>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: HelloRequest
	): HelloRequest {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* string name */ 1:
					message.name = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: HelloRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* string name = 1; */
		if (message.name !== '') writer.tag(1, WireType.LengthDelimited).string(message.name);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message hydra_provider.HelloRequest
 */
export const HelloRequest = new HelloRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HelloReply$Type extends MessageType<HelloReply> {
	constructor() {
		super('hydra_provider.HelloReply', [
			{ no: 1, name: 'message', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
		]);
	}
	create(value?: PartialMessage<HelloReply>): HelloReply {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.message = '';
		if (value !== undefined) reflectionMergePartial<HelloReply>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: HelloReply
	): HelloReply {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* string message */ 1:
					message.message = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: HelloReply,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* string message = 1; */
		if (message.message !== '') writer.tag(1, WireType.LengthDelimited).string(message.message);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message hydra_provider.HelloReply
 */
export const HelloReply = new HelloReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectionTypeMessage$Type extends MessageType<ConnectionTypeMessage> {
	constructor() {
		super('hydra_provider.ConnectionTypeMessage', [
			{
				no: 1,
				name: 'connectionType',
				kind: 'enum',
				T: () => ['hydra_provider.ConnectionType', ConnectionType]
			}
		]);
	}
	create(value?: PartialMessage<ConnectionTypeMessage>): ConnectionTypeMessage {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.connectionType = 0;
		if (value !== undefined) reflectionMergePartial<ConnectionTypeMessage>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: ConnectionTypeMessage
	): ConnectionTypeMessage {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* hydra_provider.ConnectionType connectionType */ 1:
					message.connectionType = reader.int32();
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: ConnectionTypeMessage,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* hydra_provider.ConnectionType connectionType = 1; */
		if (message.connectionType !== 0) writer.tag(1, WireType.Varint).int32(message.connectionType);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message hydra_provider.ConnectionTypeMessage
 */
export const ConnectionTypeMessage = new ConnectionTypeMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSerialPortsReply$Type extends MessageType<GetSerialPortsReply> {
	constructor() {
		super('hydra_provider.GetSerialPortsReply', [
			{
				no: 1,
				name: 'ports',
				kind: 'scalar',
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 9 /*ScalarType.STRING*/
			}
		]);
	}
	create(value?: PartialMessage<GetSerialPortsReply>): GetSerialPortsReply {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.ports = [];
		if (value !== undefined) reflectionMergePartial<GetSerialPortsReply>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: GetSerialPortsReply
	): GetSerialPortsReply {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* repeated string ports */ 1:
					message.ports.push(reader.string());
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: GetSerialPortsReply,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* repeated string ports = 1; */
		for (let i = 0; i < message.ports.length; i++)
			writer.tag(1, WireType.LengthDelimited).string(message.ports[i]);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message hydra_provider.GetSerialPortsReply
 */
export const GetSerialPortsReply = new GetSerialPortsReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetSerialConnectionRequest$Type extends MessageType<SetSerialConnectionRequest> {
	constructor() {
		super('hydra_provider.SetSerialConnectionRequest', [
			{ no: 1, name: 'portName', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
		]);
	}
	create(value?: PartialMessage<SetSerialConnectionRequest>): SetSerialConnectionRequest {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.portName = '';
		if (value !== undefined)
			reflectionMergePartial<SetSerialConnectionRequest>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: SetSerialConnectionRequest
	): SetSerialConnectionRequest {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* string portName */ 1:
					message.portName = reader.string();
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: SetSerialConnectionRequest,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* string portName = 1; */
		if (message.portName !== '') writer.tag(1, WireType.LengthDelimited).string(message.portName);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message hydra_provider.SetSerialConnectionRequest
 */
export const SetSerialConnectionRequest = new SetSerialConnectionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckConnectionReply$Type extends MessageType<CheckConnectionReply> {
	constructor() {
		super('hydra_provider.CheckConnectionReply', [
			{ no: 1, name: 'connected', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{
				no: 2,
				name: 'connectionType',
				kind: 'enum',
				T: () => ['hydra_provider.ConnectionType', ConnectionType]
			},
			{
				no: 3,
				name: 'errors',
				kind: 'scalar',
				repeat: 2 /*RepeatType.UNPACKED*/,
				T: 9 /*ScalarType.STRING*/
			}
		]);
	}
	create(value?: PartialMessage<CheckConnectionReply>): CheckConnectionReply {
		const message = globalThis.Object.create(this.messagePrototype!);
		message.connected = false;
		message.connectionType = 0;
		message.errors = [];
		if (value !== undefined) reflectionMergePartial<CheckConnectionReply>(this, message, value);
		return message;
	}
	internalBinaryRead(
		reader: IBinaryReader,
		length: number,
		options: BinaryReadOptions,
		target?: CheckConnectionReply
	): CheckConnectionReply {
		let message = target ?? this.create(),
			end = reader.pos + length;
		while (reader.pos < end) {
			let [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
				case /* bool connected */ 1:
					message.connected = reader.bool();
					break;
				case /* hydra_provider.ConnectionType connectionType */ 2:
					message.connectionType = reader.int32();
					break;
				case /* repeated string errors */ 3:
					message.errors.push(reader.string());
					break;
				default:
					let u = options.readUnknownField;
					if (u === 'throw')
						throw new globalThis.Error(
							`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
						);
					let d = reader.skip(wireType);
					if (u !== false)
						(u === true ? UnknownFieldHandler.onRead : u)(
							this.typeName,
							message,
							fieldNo,
							wireType,
							d
						);
			}
		}
		return message;
	}
	internalBinaryWrite(
		message: CheckConnectionReply,
		writer: IBinaryWriter,
		options: BinaryWriteOptions
	): IBinaryWriter {
		/* bool connected = 1; */
		if (message.connected !== false) writer.tag(1, WireType.Varint).bool(message.connected);
		/* hydra_provider.ConnectionType connectionType = 2; */
		if (message.connectionType !== 0) writer.tag(2, WireType.Varint).int32(message.connectionType);
		/* repeated string errors = 3; */
		for (let i = 0; i < message.errors.length; i++)
			writer.tag(3, WireType.LengthDelimited).string(message.errors[i]);
		let u = options.writeUnknownFields;
		if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message hydra_provider.CheckConnectionReply
 */
export const CheckConnectionReply = new CheckConnectionReply$Type();
/**
 * @generated ServiceType for protobuf service hydra_provider.Greeter
 */
export const Greeter = new ServiceType('hydra_provider.Greeter', [
	{ name: 'SayHello', options: {}, I: HelloRequest, O: HelloReply }
]);
/**
 * @generated ServiceType for protobuf service hydra_provider.ConnectionManager
 */
export const ConnectionManager = new ServiceType('hydra_provider.ConnectionManager', [
	{ name: 'GetConnectionType', options: {}, I: Empty, O: ConnectionTypeMessage },
	{ name: 'SetConnectionType', options: {}, I: ConnectionTypeMessage, O: Empty },
	{ name: 'GetSerialPorts', options: {}, I: Empty, O: GetSerialPortsReply },
	{ name: 'SetPreferredSerialPort', options: {}, I: SetSerialConnectionRequest, O: Empty },
	{ name: 'CheckConnection', options: {}, I: Empty, O: CheckConnectionReply }
]);
