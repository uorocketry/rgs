// @generated by protobuf-ts 2.9.3
// @generated from protobuf file "hydra_provider/proto/hydra_provider.proto" (package "hydra_provider", syntax proto3)
// tslint:disable
import { ConnectionManager } from './hydra_provider';
import type { CheckConnectionReply } from './hydra_provider';
import type { SetSerialConnectionRequest } from './hydra_provider';
import type { GetSerialPortsReply } from './hydra_provider';
import type { ConnectionTypeMessage } from './hydra_provider';
import type { Empty } from './hydra_provider';
import type { RpcTransport } from '@protobuf-ts/runtime-rpc';
import type { ServiceInfo } from '@protobuf-ts/runtime-rpc';
import { Greeter } from './hydra_provider';
import { stackIntercept } from '@protobuf-ts/runtime-rpc';
import type { HelloReply } from './hydra_provider';
import type { HelloRequest } from './hydra_provider';
import type { UnaryCall } from '@protobuf-ts/runtime-rpc';
import type { RpcOptions } from '@protobuf-ts/runtime-rpc';
/**
 * @generated from protobuf service hydra_provider.Greeter
 */
export interface IGreeterClient {
	/**
	 * @generated from protobuf rpc: SayHello(hydra_provider.HelloRequest) returns (hydra_provider.HelloReply);
	 */
	sayHello(input: HelloRequest, options?: RpcOptions): UnaryCall<HelloRequest, HelloReply>;
}
/**
 * @generated from protobuf service hydra_provider.Greeter
 */
export class GreeterClient implements IGreeterClient, ServiceInfo {
	typeName = Greeter.typeName;
	methods = Greeter.methods;
	options = Greeter.options;
	constructor(private readonly _transport: RpcTransport) {}
	/**
	 * @generated from protobuf rpc: SayHello(hydra_provider.HelloRequest) returns (hydra_provider.HelloReply);
	 */
	sayHello(input: HelloRequest, options?: RpcOptions): UnaryCall<HelloRequest, HelloReply> {
		const method = this.methods[0],
			opt = this._transport.mergeOptions(options);
		return stackIntercept<HelloRequest, HelloReply>('unary', this._transport, method, opt, input);
	}
}
/**
 * @generated from protobuf service hydra_provider.ConnectionManager
 */
export interface IConnectionManagerClient {
	/**
	 * @generated from protobuf rpc: GetConnectionType(hydra_provider.Empty) returns (hydra_provider.ConnectionTypeMessage);
	 */
	getConnectionType(input: Empty, options?: RpcOptions): UnaryCall<Empty, ConnectionTypeMessage>;
	/**
	 * @generated from protobuf rpc: SetConnectionType(hydra_provider.ConnectionTypeMessage) returns (hydra_provider.Empty);
	 */
	setConnectionType(
		input: ConnectionTypeMessage,
		options?: RpcOptions
	): UnaryCall<ConnectionTypeMessage, Empty>;
	/**
	 * @generated from protobuf rpc: GetSerialPorts(hydra_provider.Empty) returns (hydra_provider.GetSerialPortsReply);
	 */
	getSerialPorts(input: Empty, options?: RpcOptions): UnaryCall<Empty, GetSerialPortsReply>;
	/**
	 * @generated from protobuf rpc: SetPreferredSerialPort(hydra_provider.SetSerialConnectionRequest) returns (hydra_provider.Empty);
	 */
	setPreferredSerialPort(
		input: SetSerialConnectionRequest,
		options?: RpcOptions
	): UnaryCall<SetSerialConnectionRequest, Empty>;
	/**
	 * @generated from protobuf rpc: CheckConnection(hydra_provider.Empty) returns (hydra_provider.CheckConnectionReply);
	 */
	checkConnection(input: Empty, options?: RpcOptions): UnaryCall<Empty, CheckConnectionReply>;
}
/**
 * @generated from protobuf service hydra_provider.ConnectionManager
 */
export class ConnectionManagerClient implements IConnectionManagerClient, ServiceInfo {
	typeName = ConnectionManager.typeName;
	methods = ConnectionManager.methods;
	options = ConnectionManager.options;
	constructor(private readonly _transport: RpcTransport) {}
	/**
	 * @generated from protobuf rpc: GetConnectionType(hydra_provider.Empty) returns (hydra_provider.ConnectionTypeMessage);
	 */
	getConnectionType(input: Empty, options?: RpcOptions): UnaryCall<Empty, ConnectionTypeMessage> {
		const method = this.methods[0],
			opt = this._transport.mergeOptions(options);
		return stackIntercept<Empty, ConnectionTypeMessage>(
			'unary',
			this._transport,
			method,
			opt,
			input
		);
	}
	/**
	 * @generated from protobuf rpc: SetConnectionType(hydra_provider.ConnectionTypeMessage) returns (hydra_provider.Empty);
	 */
	setConnectionType(
		input: ConnectionTypeMessage,
		options?: RpcOptions
	): UnaryCall<ConnectionTypeMessage, Empty> {
		const method = this.methods[1],
			opt = this._transport.mergeOptions(options);
		return stackIntercept<ConnectionTypeMessage, Empty>(
			'unary',
			this._transport,
			method,
			opt,
			input
		);
	}
	/**
	 * @generated from protobuf rpc: GetSerialPorts(hydra_provider.Empty) returns (hydra_provider.GetSerialPortsReply);
	 */
	getSerialPorts(input: Empty, options?: RpcOptions): UnaryCall<Empty, GetSerialPortsReply> {
		const method = this.methods[2],
			opt = this._transport.mergeOptions(options);
		return stackIntercept<Empty, GetSerialPortsReply>('unary', this._transport, method, opt, input);
	}
	/**
	 * @generated from protobuf rpc: SetPreferredSerialPort(hydra_provider.SetSerialConnectionRequest) returns (hydra_provider.Empty);
	 */
	setPreferredSerialPort(
		input: SetSerialConnectionRequest,
		options?: RpcOptions
	): UnaryCall<SetSerialConnectionRequest, Empty> {
		const method = this.methods[3],
			opt = this._transport.mergeOptions(options);
		return stackIntercept<SetSerialConnectionRequest, Empty>(
			'unary',
			this._transport,
			method,
			opt,
			input
		);
	}
	/**
	 * @generated from protobuf rpc: CheckConnection(hydra_provider.Empty) returns (hydra_provider.CheckConnectionReply);
	 */
	checkConnection(input: Empty, options?: RpcOptions): UnaryCall<Empty, CheckConnectionReply> {
		const method = this.methods[4],
			opt = this._transport.mergeOptions(options);
		return stackIntercept<Empty, CheckConnectionReply>(
			'unary',
			this._transport,
			method,
			opt,
			input
		);
	}
}
